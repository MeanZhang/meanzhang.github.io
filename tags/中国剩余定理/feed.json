{
    "version": "https://jsonfeed.org/version/1",
    "title": "Mean 个人博客 • All posts by \"中国剩余定理\" tag",
    "description": "Mean 个人博客",
    "home_page_url": "https://blog.meancoder.xyz",
    "items": [
        {
            "id": "https://blog.meancoder.xyz/2020/MMRC/",
            "url": "https://blog.meancoder.xyz/2020/MMRC/",
            "title": "改进的混合基数转换法（MMRC）",
            "date_published": "2020-05-19T01:56:28.000Z",
            "content_html": "<p>混合基数转换法（Mixed-Radix Conversion, MRC）是求 CRT\n唯一解的方法，Kunth\n对其进行了改进。可将改算法改进为改进的混合基数转换法（Modified\nMixed-Radix Conversion, MMRC）。</p>\n<span id=\"more\"></span>\n<p>MRC 比较复杂，在这里不做介绍，可以参考<a\nhref=\"http://www.cnki.com.cn/Article/CJFDTotal-HBKX200303003.htm\">《中国剩余定理在\nRSA 解密中的应用》</a><a href=\"#fn1\" class=\"footnote-ref\" id=\"fnref1\"\nrole=\"doc-noteref\"><sup>1</sup></a>。</p>\n<h2 id=\"mmrc\">MMRC</h2>\n<p>下面来介绍一下 MMRC：</p>\n<p>设同余方程组为：</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\nx≡d_1\\pmod{p_1}\\\\\nx≡d_2\\pmod{p_2}\\\\\n......\\\\\nx≡d_s\\pmod{p_s}\\\\\n\\end{cases}\n$$</span></p>\n<ol type=\"1\">\n<li>计算<span\nclass=\"math inline\"><em>B</em><sub><em>j</em><em>i</em></sub> ← <em>p</em><sub><em>j</em></sub><sup>−1</sup> (mod  <em>p</em><sub><em>i</em></sub>)(1≤<em>j</em>&lt;<em>i</em>≤<em>s</em>)</span>；</li>\n<li>令<span\nclass=\"math inline\"><em>a</em><sub><em>i</em>1</sub> = <em>d</em><sub><em>i</em></sub>(1≤<em>i</em>≤<em>s</em>)</span>，由递推公式<span\nclass=\"math inline\"><em>a</em><sub><em>i</em>(<em>j</em>+1)</sub> = (<em>a</em><sub><em>i</em><em>j</em></sub>−<em>a</em><sub><em>j</em><em>j</em></sub>)<em>B</em><sub><em>j</em><em>i</em></sub> mod  <em>p</em><sub><em>i</em></sub>(1≤<em>j</em>&lt;<em>i</em>≤<em>s</em>)</span>，计算<span\nclass=\"math inline\"><em>a</em><sub>11</sub>, <em>a</em><sub>22</sub>, ..., <em>a</em><sub><em>s</em><em>s</em></sub></span>;</li>\n<li>计算唯一解<span\nclass=\"math inline\"><em>x</em> ← <em>a</em><sub>11</sub> + <em>a</em><sub>22</sub><em>p</em><sub>1</sub> + <em>a</em><sub>33</sub><em>p</em><sub>1</sub><em>p</em><sub>2</sub> + ... + <em>a</em><sub><em>s</em><em>s</em></sub><em>p</em><sub>1</sub><em>p</em><sub>2</sub><em>p</em><sub>3</sub>...<em>p</em><sub><em>s</em></sub></span>。</li>\n</ol>\n<p>特别地，对于只包含两个方程的方程组</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\nx≡d_1\\pmod{p_1}\\\\\nx≡d_2\\pmod{p_2}\\\\\n\\end{cases}\n$$</span></p>\n<p>可以这样计算：</p>\n<ol type=\"1\">\n<li>计算<span\nclass=\"math inline\"><em>B</em><sub>12</sub> ← <em>p</em><sub>1</sub><sup>−1</sup> (mod  <em>p</em><sub>2</sub>)</span>；</li>\n<li><span\nclass=\"math inline\"><em>a</em><sub>11</sub> = <em>d</em><sub>1</sub></span>，<span\nclass=\"math inline\"><em>a</em><sub>21</sub> = <em>d</em><sub>2</sub></span>，计算<span\nclass=\"math inline\"><em>a</em><sub>22</sub> = (<em>a</em><sub>21</sub>−<em>a</em><sub>11</sub>)<em>B</em><sub>12</sub> mod  <em>p</em><sub>2</sub></span>;</li>\n<li>计算唯一解<span\nclass=\"math inline\"><em>x</em> ← <em>a</em><sub>11</sub> + <em>a</em><sub>22</sub><em>p</em><sub>1</sub></span>。</li>\n</ol>\n<h2 id=\"mmrc-在-rsa-解密中的作用\">MMRC 在 RSA 解密中的作用</h2>\n<p>RSA 的解密过程为<span\nclass=\"math inline\"><em>M</em> = <em>C</em><sup><em>d</em></sup> mod  <em>N</em></span>，而<span\nclass=\"math inline\"><em>N</em> = <em>p</em><em>q</em></span>且<span\nclass=\"math inline\"><em>p</em></span>和<span\nclass=\"math inline\"><em>q</em></span>互素，所以 M 可以通过下式求出：</p>\n<p><span class=\"math display\">$$\n\\begin{cases}\nm_1≡C^d\\pmod p\\\\\nm_2≡C^d\\pmod q\\\\\n\\end{cases}\n$$</span></p>\n<p>其中<span\nclass=\"math inline\"><em>m</em><sub>1</sub> = <em>C</em><sup><em>d</em></sup> mod  <em>p</em></span>，<span\nclass=\"math inline\"><em>m</em><sub>2</sub> = <em>C</em><sup><em>d</em></sup> mod  <em>q</em></span>。</p>\n<p>由此我们可以得到快速解密的算法：</p>\n<ol type=\"1\">\n<li>计算<span\nclass=\"math inline\"><em>m</em><sub>1</sub> ← (<em>C</em> mod  <em>p</em>)<sup><em>d</em> mod  <em>p</em> − 1</sup> mod  <em>p</em></span>，<span\nclass=\"math inline\"><em>m</em><sub>2</sub> ← (<em>C</em> mod  <em>q</em>)<sup><em>d</em> mod  <em>q</em> − 1</sup> mod  <em>q</em></span>；</li>\n<li>计算<span\nclass=\"math inline\"><em>p</em><sup>−1</sup> (mod  <em>q</em>)</span>；</li>\n<li>计算<span\nclass=\"math inline\"><em>t</em> ← <em>p</em><sup>−1</sup>(<em>m</em><sub>2</sub>−<em>m</em><sub>1</sub>) mod  <em>q</em></span>；</li>\n<li>计算明文<span\nclass=\"math inline\"><em>M</em> ← <em>m</em><sub>1</sub> + <em>t</em><em>p</em></span>。</li>\n</ol>\n<p>在第 1 步中，由于<span\nclass=\"math inline\"><em>p</em></span>是素数，由费马小定理<a href=\"#fn2\"\nclass=\"footnote-ref\" id=\"fnref2\"\nrole=\"doc-noteref\"><sup>2</sup></a>可得，<span\nclass=\"math inline\"><em>C</em><sup><em>p</em> − 1</sup> ≡ 1 (mod  <em>p</em>)</span>，所以<span\nclass=\"math inline\">(<em>C</em> mod  <em>p</em>)<sup><em>d</em> mod  <em>p</em> − 1</sup> mod  <em>p</em> = <em>C</em><sup><em>d</em></sup> mod  <em>p</em></span>，<span\nclass=\"math inline\"><em>m</em><sub>2</sub></span>同理。</p>\n<p>下面给出我的代码，完整代码见<a\nhref=\"https://github.com/MeanZhang/RSA\">MeanZhang/RSA:\nRSA-Java</a>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * RSA解密</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用了MMRC算法</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> c 密文</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> d 私钥d</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> p p</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> q q</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 明文</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> BigInteger <span class=\"title function_\">decrypt</span><span class=\"params\">(BigInteger c, BigInteger d, BigInteger p, BigInteger q)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// m1 ≡ c^d ≡ (c mod p)^(d mod (p-1))(mod p)</span></span><br><span class=\"line\">    <span class=\"type\">BigInteger</span> <span class=\"variable\">m1</span> <span class=\"operator\">=</span> c.mod(p).modPow(d.mod(p.subtract(BigInteger.ONE)), p);</span><br><span class=\"line\">    <span class=\"comment\">// m2 ≡ c^d ≡ (c mod q)^(d mod (q-1))(mod q)</span></span><br><span class=\"line\">    <span class=\"type\">BigInteger</span> <span class=\"variable\">m2</span> <span class=\"operator\">=</span> c.mod(q).modPow(d.mod(q.subtract(BigInteger.ONE)), q);</span><br><span class=\"line\">    <span class=\"type\">BigInteger</span> <span class=\"variable\">invP</span> <span class=\"operator\">=</span> p.modInverse(q);</span><br><span class=\"line\">    <span class=\"comment\">// t = p^(-1) * (m2-m1) mod q</span></span><br><span class=\"line\">    <span class=\"type\">BigInteger</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> invP.multiply(m2.subtract(m1)).mod(q);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m1.add(t.multiply(p));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\">参考资料</h2>\n<aside id=\"footnotes\" class=\"footnotes footnotes-end-of-document\"\nrole=\"doc-endnotes\">\n<hr />\n<ol>\n<li id=\"fn1\"><p><a\nhref=\"http://www.cnki.com.cn/Article/CJFDTotal-HBKX200303003.htm\">中国剩余定理在\nRSA 解密中的应用–《河北省科学院学报》2003 年 03 期</a><a href=\"#fnref1\"\nclass=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\n<li id=\"fn2\"><p><a\nhref=\"https://zh.wikipedia.org/wiki/费马小定理\">费马小定理 -\n维基百科，自由的百科全书</a><a href=\"#fnref2\" class=\"footnote-back\"\nrole=\"doc-backlink\">↩︎</a></p></li>\n</ol>\n</aside>\n",
            "tags": [
                "密码学",
                "RSA",
                "抽象代数",
                "中国剩余定理"
            ]
        }
    ]
}